{
  "T_destination": "TypeVar",
  "_apply": "method, signature=(fn, recurse=True)",
  "_backward_hooks": "OrderedDict",
  "_backward_pre_hooks": "OrderedDict",
  "_buffers": "OrderedDict",
  "_call_impl": "method, signature=(*args, **kwargs)",
  "_compiled_call_impl": "NoneType",
  "_forward_hooks": "OrderedDict",
  "_forward_hooks_always_called": "OrderedDict",
  "_forward_hooks_with_kwargs": "OrderedDict",
  "_forward_pre_hooks": "OrderedDict",
  "_forward_pre_hooks_with_kwargs": "OrderedDict",
  "_get_backward_hooks": "method, signature=()",
  "_get_backward_pre_hooks": "method, signature=()",
  "_get_name": "method, signature=()",
  "_is_full_backward_hook": "NoneType",
  "_is_hf_initialized": "bool",
  "_load_from_state_dict": "method, signature=(state_dict, prefix, local_metadata, strict, missing_keys, unexpected_keys, error_msgs)",
  "_load_state_dict_post_hooks": "OrderedDict",
  "_load_state_dict_pre_hooks": "OrderedDict",
  "_maybe_warn_non_full_backward_hook": "method, signature=(inputs, result, grad_fn)",
  "_modules": "OrderedDict",
  "_named_members": "method, signature=(get_members_fn, prefix='', recurse=True, remove_duplicate: bool = True)",
  "_non_persistent_buffers_set": "set",
  "_parameters": "OrderedDict",
  "_register_load_state_dict_pre_hook": "method, signature=(hook, with_module=False)",
  "_register_state_dict_hook": "method, signature=(hook)",
  "_replicate_for_data_parallel": "method, signature=()",
  "_save_to_state_dict": "method, signature=(destination, prefix, keep_vars)",
  "_slow_forward": "method, signature=(*input, **kwargs)",
  "_state_dict_hooks": "OrderedDict",
  "_state_dict_pre_hooks": "OrderedDict",
  "_version": "int",
  "_wrapped_call_impl": "method, signature=(*args, **kwargs)",
  "add_module": "method, signature=(name: str, module: Optional[ForwardRef('Module')]) -> None",
  "apply": "method, signature=(fn: Callable[[ForwardRef('Module')], NoneType]) -> ~T",
  "attn_drop": "Dropout, signature=(*args, **kwargs)",
  "bfloat16": "method, signature=() -> ~T",
  "buffers": "method, signature=(recurse: bool = True) -> Iterator[torch.Tensor]",
  "call_super_init": "bool",
  "children": "method, signature=() -> Iterator[ForwardRef('Module')]",
  "compile": "method, signature=(*args, **kwargs)",
  "cpu": "method, signature=() -> ~T",
  "cuda": "method, signature=(device: Union[int, torch.device, NoneType] = None) -> ~T",
  "double": "method, signature=() -> ~T",
  "dump_patches": "bool",
  "eval": "method, signature=() -> ~T",
  "extra_repr": "method, signature=() -> str",
  "float": "method, signature=() -> ~T",
  "forward": "method, signature=(x)",
  "fused_attn": "bool",
  "get_buffer": "method, signature=(target: str) -> 'Tensor'",
  "get_extra_state": "method, signature=() -> Any",
  "get_parameter": "method, signature=(target: str) -> 'Parameter'",
  "get_submodule": "method, signature=(target: str) -> 'Module'",
  "half": "method, signature=() -> ~T",
  "head_dim": "int",
  "ipu": "method, signature=(device: Union[int, torch.device, NoneType] = None) -> ~T",
  "k_norm": "Identity, signature=(*args, **kwargs)",
  "load_state_dict": "method, signature=(state_dict: Mapping[str, Any], strict: bool = True, assign: bool = False)",
  "modules": "method, signature=() -> Iterator[ForwardRef('Module')]",
  "named_buffers": "method, signature=(prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.Tensor]]",
  "named_children": "method, signature=() -> Iterator[Tuple[str, ForwardRef('Module')]]",
  "named_modules": "method, signature=(memo: Optional[Set[ForwardRef('Module')]] = None, prefix: str = '', remove_duplicate: bool = True)",
  "named_parameters": "method, signature=(prefix: str = '', recurse: bool = True, remove_duplicate: bool = True) -> Iterator[Tuple[str, torch.nn.parameter.Parameter]]",
  "num_heads": "int",
  "parameters": "method, signature=(recurse: bool = True) -> Iterator[torch.nn.parameter.Parameter]",
  "proj": "Linear, signature=(*args, **kwargs)",
  "proj_drop": "Dropout, signature=(*args, **kwargs)",
  "q_norm": "Identity, signature=(*args, **kwargs)",
  "qkv": "Linear, signature=(*args, **kwargs)",
  "register_backward_hook": "method, signature=(hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]]) -> torch.utils.hooks.RemovableHandle",
  "register_buffer": "method, signature=(name: str, tensor: Optional[torch.Tensor], persistent: bool = True) -> None",
  "register_forward_hook": "method, signature=(hook: Union[Callable[[~T, Tuple[Any, ...], Any], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any], Any], Optional[Any]]], *, prepend: bool = False, with_kwargs: bool = False, always_call: bool = False) -> torch.utils.hooks.RemovableHandle",
  "register_forward_pre_hook": "method, signature=(hook: Union[Callable[[~T, Tuple[Any, ...]], Optional[Any]], Callable[[~T, Tuple[Any, ...], Dict[str, Any]], Optional[Tuple[Any, Dict[str, Any]]]]], *, prepend: bool = False, with_kwargs: bool = False) -> torch.utils.hooks.RemovableHandle",
  "register_full_backward_hook": "method, signature=(hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor], Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle",
  "register_full_backward_pre_hook": "method, signature=(hook: Callable[[ForwardRef('Module'), Union[Tuple[torch.Tensor, ...], torch.Tensor]], Union[NoneType, Tuple[torch.Tensor, ...], torch.Tensor]], prepend: bool = False) -> torch.utils.hooks.RemovableHandle",
  "register_load_state_dict_post_hook": "method, signature=(hook)",
  "register_module": "method, signature=(name: str, module: Optional[ForwardRef('Module')]) -> None",
  "register_parameter": "method, signature=(name: str, param: Optional[torch.nn.parameter.Parameter]) -> None",
  "register_state_dict_pre_hook": "method, signature=(hook)",
  "requires_grad_": "method, signature=(requires_grad: bool = True) -> ~T",
  "scale": "float",
  "set_extra_state": "method, signature=(state: Any)",
  "share_memory": "method, signature=() -> ~T",
  "state_dict": "method, signature=(*args, destination=None, prefix='', keep_vars=False)",
  "to": "method, signature=(*args, **kwargs)",
  "to_empty": "method, signature=(*, device: Union[int, str, torch.device, NoneType], recurse: bool = True) -> ~T",
  "train": "method, signature=(mode: bool = True) -> ~T",
  "training": "bool",
  "type": "method, signature=(dst_type: Union[torch.dtype, str]) -> ~T",
  "xpu": "method, signature=(device: Union[int, torch.device, NoneType] = None) -> ~T",
  "zero_grad": "method, signature=(set_to_none: bool = True) -> None"
}